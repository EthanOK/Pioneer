
>- 原文链接：https://davidederosa.com/basic-blockchain-programming/bytes-and-hashes/
>- 译者：[AI翻译官](https://learnblockchain.cn/people/19584)，校对：[翻译小组](https://learnblockchain.cn/people/412)
>- 本文永久链接：[learnblockchain.cn/article…](https://learnblockchain.cn/article/8613)
    
本文代码[在 GitHub 上查看](https://github.com/keeshux/basic-blockchain-programming "字节和哈希")

哈希算法在比特币生态系统中占据重要地位，你会在区块链中到处找到它们，所以我认为这是最好的起点。

在我们开始之前，请记住，几乎所有的区块链数据结构都是以[小端](http://en.wikipedia.org/wiki/Endianness#Little-endian)方式进行序列化的，而少数对象（如网络地址）保留[大端](http://en.wikipedia.org/wiki/Endianness#Big-endian)字节顺序。如果没有另外说明，我假设我们正在讨论和处理小端机器。花点时间，尽量不要感到困惑，否则一旦加入对等网络，可能会发生奇怪的事情。

### 比特币哈希函数

就我们而言， [哈希函数](http://en.wikipedia.org/wiki/Hash_function)将任意数量的字节转换为固定长度的字节。暂时忘记不可逆性和其他内容，因为我们现在要坚持的是固定长度这个属性。在其他用途中，比特币依赖哈希用于几个关键目的：

*   标识符
*   地址
*   交易签名
*   [校验和](http://en.wikipedia.org/wiki/Checksum)和其他验证

比特币非常有趣，因为它采用了计算机科学中已经建立的，有时是基本的概念，创造出了一些令人惊叹的创新。哈希也不例外，因为中本聪使用了 [SHA-2](http://en.wikipedia.org/wiki/SHA-2) 和[RIPEMD](http://en.wikipedia.org/wiki/RIPEMD)的组合，而不是定义自己的加密函数。

具体来说，他引入了两个复合哈希函数：

*   _hash256_(d) = SHA-256(SHA-256(d))
*   _hash160_(d) = RIPEMD-160(SHA-256(d))

其中，SHA-256 是 SHA-2 的 256 位变体，RIPEMD-160 是 RIPEMD 的 160 位变体，_d_ 是一个通用的字节数组。难怪 hash256 和 hash160 函数分别返回 256 位（32 字节）和 160 位（20 字节）的数组。

双重哈希的选择是出于个人原因还是安全原因？抱歉我不是一个加密极客，但这里有[一些讨论](https://bitcointalk.org/index.php?topic=45456.0)。

### 用于标识符的 Hash256

如果你对网络钱包或网络区块浏览器有一定了解，你至少曾经遇到过 hash256，因为这是区块链用来识别其核心实体（区块和交易）的哈希类型。

考虑一下到[此区块](https://blockstream.info/block/00000000000000000ffd0d82302d4225aaa0ccfa29dc329f9e966b8fc83cbea5)或[此交易](https://blockstream.info/tx/46287164db45a78a9196257da45b62881e394a3d11fb403943bbbf8ec4aaf9ee)的链接，在区块链中跳过你不理解的部分，关注两个 URL 的最后一个组件，你也会在网页的某个地方看到。这些长字符串是区块链数据库中的主键，你可以使用该标识符访问唯一的区块（交易），并且保证没有其他区块（交易）会具有相同的标识符。也许你还注意到区块和交易 ID 共享的另一个属性是它们的长度，即 64 个字符。

回到极客的东西。这些字符串还有一点：它们由十六进制数字（0-9 a-f）组成。作为程序员，当你处理十六进制时，脑海中立即响起警铃，对吧？每个十六进制对表示一个字节的数据，通过简单的计算，你会发现 64 个十六进制数字的字符串是一个 32 字节的数组，就像 hash256 一样。事实上，这两个标识符都是通过 hash256 计算得出的：

*   _block\_id_ = hash256(block.header)
*   _transaction\_id_ = hash256(transaction)

我们稍后会深入研究区块和交易，但这是值得从一开始注意的 hash256 的一个应用。hash256 的其他用途将在后面解释。

### 用于地址的 Hash160

如果 hash256 是比特币哈希的王者，毫无疑问，hash160 就是皇后。我知道只有两个，但设定一些重要性的顺序是很好的——希望你不要因为性别歧视而责怪我。尽管如此，即使 hash256 遍布整个区块链，hash160 仍然统治着一个你肯定听说过的战略要地：_地址_！

不要像许多其他教程那样急于了解地址，直到你对交易有了相当的了解，否则它们将毫无意义。耐心点，我们将详细介绍它们。

### 网络中的哈希

区块和交易哈希遵循小端规则，这就是为什么当你尝试发布原始交易时，当你回头查看网络浏览器时可能会感到困惑。例如，将上述交易的 64 个字符哈希（有时称为_txid_）视为在 blockchain.info 上看到的，然后将其拆分为 32 组 2 个十六进制数字（每个字节一个）：

```
    46 28 71 64 db 45 a7 8a
    91 96 25 7d a4 5b 62 88
    1e 39 4a 3d 11 fb 40 39
    43 bb bf 8e c4 aa f9 ee
```    

假设我们想在代码中处理这个，最适合的是一个数组：

```
    unsigned char txid[32] = { 0x46, 0x28, 0x71, ..., 0xee };
```

现在考虑 txid 的性质，一个大的多字节整数（256 位）存储在一个数组中，因为缺乏合适的原始类型。我们的粗略猜测期望`46`是最重要的字节（最左边的字节），因为它在字符串中最左边，但我们将其存储在最低的索引处。如果我们在英特尔机器上，`46`将成为最不重要的字节（最右边的字节）。弱~

这里有一个不太直观的编码：
```
    unsigned char txid[32] = { 0xee, ..., 0x71, 0x28, 0x46 };
```

看到`46`现在是数组的最重要字节（对于将更重要的字节存储在更高的内存位置的小端机器来说）吗？好的，现在这终于有意义了。

在处理原始比特币流时，请记住这一点，因为一个直接的结果是我们在网络中看到“反转的哈希”。

### 下一篇

你了解到比特币区块链主要是一个小端怪物，我们有责任提交其他节点能够识别的二进制数据。区块和交易都有形成的主键，基本上是它们自己字节（或部分字节）的哈希。比特币哈希函数通常是建立在其他已经建立的哈希函数之上的。

在[下一篇文章](https://davidederosa.com/basic-blockchain-programming/serialization-part-one/)中，我们将分析_序列化_并为一些真正的代码做好准备。如果你喜欢这篇文章，请分享。

> 我是 [AI 翻译官](https://learnblockchain.cn/people/19584)，为大家转译优秀英文文章，如有翻译不通的地方，在[这里](https://github.com/lbc-team/Pioneer/blob/master/translations/8613.md)修改，还请包涵～